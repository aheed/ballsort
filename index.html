<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>Ball Sorter</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <svg id="backdrop" height="500" width="500">
      Sorry, your browser does not support inline SVG.
    </svg>
    <div id="spotlight"></div>
    <svg id="movers-svg" height="500" width="500">
        Sorry, your browser does not support inline SVG.
    </svg>
    <br>
    <div id="button-container">
      <button id="move-up" type="button">‚¨ÜÔ∏è</button>
      <button id="move-down" type="button">‚¨áÔ∏è</button>
      <button id="move-left" type="button">‚¨ÖÔ∏è</button>
      <button id="move-right" type="button">‚û°Ô∏è</button>  
      <button id="claw-toggle" type="button">ü§è</button>
    </div>
    <div id="status-msg">starting up...</div>
    <script type="module" src="constants.js"></script>
    <script type="module" src="backdrop.js"></script>
    <script type="module" src="ball.js"></script>
    <script type="module">
      import {hDistance, vDistance, vTopSpace, originX, originY} from "./constants.js";
      import {recreateBackdrop} from "./backdrop.js";
      import {createBallWrapper, createBall} from "./ball.js";

      const statusMsg = document.querySelector("#status-msg");
      const upButton = document.querySelector("#move-up");
      const downButton = document.querySelector("#move-down");
      const leftButton = document.querySelector("#move-left");
      const rightButton = document.querySelector("#move-right");
      const clawButton = document.querySelector("#claw-toggle");
      const moversSvg = document.querySelector("#movers-svg");
      const spotlight = document.querySelector("#spotlight");
      const rootElem = document.querySelector(":root");      
      const vOffsetClaw = -25;
      const vSpotLightOffset = 51;
      const hSpotLightOffset = 30;
      
      const nofMovers = 20;
      const cb0Min = 0.55;
      const cb0Max = 0.95;
      const cb1Min = 0.1;
      const cb1Max = 0.1;
      const cb2Min = 0.5;
      const cb2Max = 0.6;
      const cb3Min = 1.0;
      const cb3Max = 1.4;

      const clawOpenAngleDegrees = 58;
      const clawClosedAngleDegrees = 25;
      const ballHolderOffset = 24;
      const baseHDurationSeconds = 1.0;
      const baseVDurationSeconds = 1.5;
      const baseClawDurationSeconds = 0.3;
      const baseSpotlightDurationSeconds = 0.4;

      let claw = {
        clawOpen: false,
        hPosIndex: 0,
        vPosIndex: 0,
        clawLeft: null,
        clawRight: null,
        hMovers: [],
        vMovers: [],
        ballHolderInClawElem: null,
        ballInClaw: null
      }
      
      let maxX = 3;
      let maxY = 4;
      
      let spotlightOn = false;
      let hSpotlightPosIndex = 0;
      let vSpotlightPosIndex = 0;

      const ipol = (index, min, max, maxIndex) => min + index * (max - min) / maxIndex;
      const ipolCurried = (min, max, maxIndex) => (index) => ipol(index, min, max, maxIndex);
      const ipolCurriedMax = (maxIndex) => (min, max) => ipolCurried(min, max, maxIndex);
      const ipolCurriedMaxFun = ipolCurriedMax(nofMovers - 1);
      const ipFun0 = ipolCurriedMaxFun(cb0Min, cb0Max);
      const ipFun1 = ipolCurriedMaxFun(cb1Min, cb1Max);
      const ipFun2 = ipolCurriedMaxFun(cb2Min, cb2Max);
      const ipFun3 = ipolCurriedMaxFun(cb3Min, cb3Max);

      const setClawAttributes = (elem) => {
        elem.setAttribute('fill', "none");
        elem.setAttribute('stroke', "black");
        elem.setAttribute('stroke-width', "8");
        elem.setAttribute('transform-origin', `${originX}px ${originY}px`);
        elem.classList.add('claw');
      }
            
      for (let i=0; i<nofMovers; i++) {
        const vMover = document.createElementNS("http://www.w3.org/2000/svg", 'g');
        vMover.classList.add('v-move');
        claw.vMovers.push(vMover);
        let mover;
        if (i < (nofMovers - 1)) {
          mover = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
          mover.setAttribute('stroke', 'none');
          mover.setAttribute('fill', 'black');
          mover.setAttribute('cx', `${originX}`);
          mover.setAttribute('cy', `${originY}`);
          mover.setAttribute('r', '11');
          mover.setAttribute('stroke-width', '3');
        }
        else {
          mover = document.createElementNS("http://www.w3.org/2000/svg", 'g');
          const ballHolder = document.createElementNS("http://www.w3.org/2000/svg", 'g');
          ballHolder.style.transform = `translateY(${ballHolderOffset}px)`;
          mover.appendChild(ballHolder);
          claw.ballHolderInClawElem = ballHolder;
          vMover.classList.add('claw-wrapper');
          claw.clawRight = document.createElementNS("http://www.w3.org/2000/svg", 'path');
          claw.clawRight.setAttribute('id', "claw-right");
          claw.clawRight.setAttribute('d', `M${originX},${originY} a20,20 0 0,1 0,40`);
          setClawAttributes(claw.clawRight);
          mover.appendChild(claw.clawRight);

          claw.clawLeft = document.createElementNS("http://www.w3.org/2000/svg", 'path');
          claw.clawLeft.setAttribute('id', "claw-left");
          claw.clawLeft.setAttribute('d', `M${originX},${originY} a20,20 0 0,0 0,40`);
          setClawAttributes(claw.clawLeft);
          mover.appendChild(claw.clawLeft);

          const clawHinge = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
          clawHinge.setAttribute('fill', 'black');
          clawHinge.setAttribute('cx', `${originX}`);
          clawHinge.setAttribute('cy', `${originY - 2}`);
          clawHinge.setAttribute('r', '6');
          clawHinge.setAttribute('stroke', 'none');
          mover.appendChild(clawHinge);

          const clawBolt = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
          clawBolt.setAttribute('fill', 'white');
          clawBolt.setAttribute('cx', `${originX}`);
          clawBolt.setAttribute('cy', `${originY - 2}`);
          clawBolt.setAttribute('r', '2');
          clawBolt.setAttribute('stroke', 'none');
          mover.appendChild(clawBolt);
        }
        const transFun = `cubic-bezier(${ipFun0(i)}, ${ipFun1(i)}, ${ipFun2(i)}, ${ipFun3(i)}`;
        mover.style['transition-timing-function'] = transFun;
        mover.classList.add('h-move');
        claw.hMovers.push(mover);
        vMover.appendChild(mover);
      }

      claw.vMovers.forEach(vMover => {
        moversSvg.appendChild(vMover);
      });

      const createBallInClaw = (color, text) => {
        const wrapper = createBallWrapper(color, text);
        return {wrapper: wrapper, color: color, text: text};
      }

      let balls = [];
      
      balls.push(createBall(0, 1, 'lightblue', '?'));
      balls.push(createBall(0, 2, 'red', '0'));
      balls.push(createBall(0, 3, 'pink', '12'));
      balls.push(createBall(0, 4, 'green', '233'));
      balls.push(createBall(1, 4, 'green', 'A'));
      balls.push(createBall(2, 4, 'lightyellow', 'üçÑ'));
      balls.push(createBall(3, 4, 'green', 'x'));

      /*ballInClaw = createBallInClaw('orange');
      claw.ballHolderInClawElem.appendChild(claw.ballInClaw.wrapper);
      */

      /*let highlights =[
        {xMin: 2, xMax: 3, yMin:2, yMax:3, color: "lightblue"},
        {xMin: 0, xMax: 0, yMin:0, yMax:3, color: "lightyellow"}];*/
      let highlights =[];
      
      recreateBackdrop(maxX, maxY, highlights);

      const updateDurations = (multiplier) => {
        rootElem.style.setProperty('--h-duration', `${baseHDurationSeconds * multiplier}s`);
        rootElem.style.setProperty('--v-duration', `${baseVDurationSeconds * multiplier}s`);
        rootElem.style.setProperty('--claw-duration', `${baseClawDurationSeconds * multiplier}s`);
        rootElem.style.setProperty('--spotlight-duration', `${baseSpotlightDurationSeconds * multiplier}s`);
      }


      const updatePositions = () => {
        const hPos = claw.hPosIndex * hDistance;
        console.log(`hPosIx: ${claw.hPosIndex} vPosIx: ${claw.vPosIndex} hPos:${hPos}`);
        const vPosFun = ipolCurried(0, vTopSpace + vOffsetClaw + claw.vPosIndex * vDistance, claw.vMovers.length - 2);
        claw.hMovers.forEach((mover, i) => {
            mover.style.transform = `translateX(${hPos}px)`;
        });
        claw.vMovers.forEach((mover, i) => {
          let index = i;
          let offset = -15;
          if (mover.classList.contains('claw-wrapper')) {
            index = index - 1;
            offset = 1;
          }

          let vPos = vPosFun(index) + offset;
          mover.style.transform = `translateY(${vPos}px)`;
        });
        const clawAngleDegrees = claw.clawOpen ? clawOpenAngleDegrees : clawClosedAngleDegrees;
        claw.clawRight.style.transform = `rotate(${-clawAngleDegrees}deg)`;
        claw.clawLeft.style.transform = `rotate(${clawAngleDegrees}deg)`;

        spotlight.style.visibility = spotlightOn ? "visible" : "hidden";
        const spotLightX = hSpotLightOffset + hSpotlightPosIndex * hDistance;
        const spotLightY = vTopSpace + vSpotLightOffset + vSpotlightPosIndex * vDistance;
        spotlight.style.transform = `translate(${spotLightX}px, ${spotLightY}px)`;

        balls.forEach((ball) => {
          const hPosBall = ball.hIndex * hDistance;
          const vPosBall = vTopSpace + ball.vIndex * vDistance;
          ball.wrapper.style.transform = `translate(${hPosBall}px, ${vPosBall}px)`;
        });
      }

      const downClickHandler = (e) => {
        if (claw.vPosIndex >= maxY) {
          // Already at bottom. Do nothing.
          return;
        }
        console.log("move down");
        claw.vPosIndex = claw.vPosIndex + 1;
        updatePositions();
      }

      const upClickHandler = (e) => {
        if (claw.vPosIndex == 0) {
          // Already at top. Do nothing.
          return;
        }
        console.log("move up");
        claw.vPosIndex = claw.vPosIndex - 1;
        updatePositions();
      }

      const leftClickHandler = (e) => {
        if (claw.hPosIndex == 0) {
          // Already at leftmost position. Do nothing.
          return;
        }
        console.log("move left");
        claw.hPosIndex = claw.hPosIndex - 1;
        updatePositions();
      }

      const rightClickHandler = (e) => {
        if (claw.hPosIndex >= maxX) {
          // Already at rightmost position. Do nothing.
          return;
        }
        console.log("move right");
        claw.hPosIndex = claw.hPosIndex + 1;
        updatePositions();
      }

      const openOrCloseClaw = (open) => {
        if (claw.clawOpen == open) {
          return;
        }

        claw.clawOpen = !claw.clawOpen;
        if(claw.clawOpen) {
          if (!!claw.ballInClaw) {
            console.log("Dropping ball");
            balls.push(createBall(claw.hPosIndex, claw.vPosIndex, claw.ballInClaw.color, claw.ballInClaw.text));
            claw.ballHolderInClawElem.removeChild(claw.ballInClaw.wrapper);
            claw.ballInClaw = null;
          }
        }
        else {
          const ballToGrab = balls.find((ball) => ball.hIndex == claw.hPosIndex && ball.vIndex == claw.vPosIndex);
          if (!!ballToGrab) {
            console.log("Grabbing ball");
            claw.ballInClaw = createBallInClaw(ballToGrab.color, ballToGrab.text);
            claw.ballHolderInClawElem.appendChild(claw.ballInClaw.wrapper);
            moversSvg.removeChild(ballToGrab.wrapper);
            balls = balls.filter((ball) => ball != ballToGrab);
          }
        }
        updatePositions();
      }

      const clawClickHandler = (e) => {
        openOrCloseClaw(!claw.clawOpen);
      }

      upButton.addEventListener("click", upClickHandler);
      downButton.addEventListener("click", downClickHandler);
      leftButton.addEventListener("click", leftClickHandler);
      rightButton.addEventListener("click", rightClickHandler);
      clawButton.addEventListener("click", clawClickHandler);
      clawButton.focus();
      updateDurations(1.0);
      updatePositions();

      console.log("so far so good");
      statusMsg.innerText = "";
      
      const handleMessage = (msg) => {
        console.log("handleMessage ", msg);

        if (!!msg.delay_multiplier) {
          updateDurations(msg.delay_multiplier);
        }

        const newState = msg.state;

        if (!!newState.max_x) {
          maxX = newState.max_x;
          maxY = newState.max_y;
          recreateBackdrop(maxX, maxY, highlights);
        }

        if (!!newState.highlights) {
          highlights = newState.highlights;
          recreateBackdrop(maxX, maxY, highlights);
        }

        if (!!newState.spotlight) {
          spotlightOn = newState.spotlight.on;
          hSpotlightPosIndex = newState.spotlight.x;
          vSpotlightPosIndex = newState.spotlight.y;
        }

        if (!!newState.balls ) {
          if (!!claw.ballInClaw) {
            claw.ballHolderInClawElem.removeChild(claw.ballInClaw.wrapper);
            claw.ballInClaw = null;
          }

          balls.forEach((ball) => {
            moversSvg.removeChild(ball.wrapper);
          });
          balls = newState.balls.map((ball) => createBall(ball.pos.x, ball.pos.y, ball.color, ball.label));
        }

        if (!!newState.elapsed) {
          statusMsg.innerText =  `Virtual time elapsed: ${newState.elapsed.toFixed(2)} seconds ${newState.goal_accomplished ? "‚úÖ" : ""}`;
        }

        if (!!newState.goal_accomplished) {

        }

        hPosIndex = newState.claw.pos.x;
        vPosIndex = newState.claw.pos.y;
        
        openOrCloseClaw(newState.claw.open);

        updatePositions();
      }

      // Listen to PostMessage messages
      window.addEventListener(
        "message",
        (event) => {
          event.preventDefault();
          console.log(`state update from ${event.origin}`);
          const stateUpdateMsg = JSON.parse(event.data);
          handleMessage(stateUpdateMsg);
        },
        false,
      );

    </script>
  </body>
</html>